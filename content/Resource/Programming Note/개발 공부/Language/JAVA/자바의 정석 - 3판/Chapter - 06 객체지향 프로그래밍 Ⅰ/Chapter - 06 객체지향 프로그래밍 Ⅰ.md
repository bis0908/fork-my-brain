---

1. 클래스와 객체
    1. 클래스
        1. 정의: 객체를 정의해 놓은 것.
        2. 용도: 객체를 생성하는데 사용.
        3. 사용자 정의 타입: 프로그래밍 언어에서 제공하는 자료형 외 프로그래머가 서로 관련된 변수들을 묶어 하나의 타입으로 추가하는 것.
    2. 객체
        
        1. 정의: 실제로 존재하는 사물 혹은 개념.
        2. 용도: 객체의 기능과 속성에 따라 다르다.
        3. 구성요소
            1. 속성: 멤버변수, 특성, 필드, 상태.
            2. 기능: 메서드, 함수, 행위
            3. 예를 들어 TV라는 객체가 있다면
                
                1. 속성: 크기, 색상, 볼륨, 채널 등
                2. 기능: 켜기/끄기, 볼륨 조절, 채널 변경하기 등
                
                ```java
                class Tv {	String color;	boolean power;	int channel;	void power() {		power = !power;	}	void channelUp() {		channel++;	}	void channelDown() {		channel--;	}}
                ```
                
        
          
        
2. 인스턴스
    
    1. 클래스로부터 객체를 만드는 과정을 인스턴스화 라고 한다.
    2. 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
    3. 클래스를 바로 갖다 쓰는게 아니라 공장처럼 찍어낸 객체(인스턴스)를 만들어서 쓰는게 핵심
    4. 생성 방법
        
        ```java
        Tv t = new Tv();  // Tv 클래스 타입의 참조변수 t에 Tv 인스턴스를 생성하여 '인스턴스의 주소'를									// t에 저장한다
        ```
        
        - 단계별
        
        ```java
        Tv t;
        ```
        
        ```java
        t = new Tv();
        ```
        
    
    💡
    
    Instance는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과  
    일치해야 한다.
    
      
    
3. 객체의 배열
    
    1. 많은 수의 객체를 다뤄야할 때 배열을 사용하면 된다.
    
    ```
    // exampleTv[] tvArr = new Tv[3];// 객체 수가 많을 때는 반복문을 이용한다.Tv[] tvArr = new Tv[100];for (int i = 0; i < tvArr.length; i++) {	tvArr[i] = new Tv();}
    ```
    

  

1. 변수
    1. 변수의 종류
        
        1. class 변수 (class 영역)
            1. 클래스가 메모리에 올라갈 때 생성.
            2. 인스턴스 공통 값을 유지 해야하는 속성의 경우 선언.
        2. instance 변수 (class 영역)
            1. 인스턴스가 생성되었을때 생성.
            2. 인스턴스별로 고유의 상태를 유지해야하는 속성의 경우 선언.
        3. local 변수 (메서드, 생성자, 초기화 블록 내부)
            1. 변수 선언문이 수행될때 생성.
        
        💡
        
        인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 각기 다른 값을 가질 수 있지만 클래스 변수는 모든 인스턴스가 하나의 저장 공간을 공유하므로 항상 공통된 값을 갖는다.
        

  

1. 메서드
    1. 특정 작업을 수행하는 일련의 문장들을 하나로 엮은 것.
    2. 수학의 함수와 유사하다.
    3. 메서드를 사용하는 이유
        1. 높은 재사용성
        2. 중복 코드의 제거
        3. 프로그램의 구조화
    4. 선언과 구현
        
        ```
        // 반환타입 메서드이름 (타입 변수명, 타입 변수명, ...)int add (int a, int b) {  // 선언부	int result = a + b;  // 구현부	return result;}
        ```
        
    5. 반환 타입
        1. return 값의 타입을 선언부에서 정하면 된다.
        2. return 값이 int면 선언부에 int가 붙는 식. 반환값이 없으면 void.
        3. 반환타입이 일치하거나 적어도 ==**자동 형변환이 가능한 것이어야**== 함.
            
            ```java
            void print () {  	System.out.println("이것은 출력문이지 반환되는 값이 아니다");}  // void문은 컴파일러가 메서드의 마지막에 자동으로 return을 추가해준다.
            ```
            
        4. 참조형 반환 타입
            1. 반환타입도 참조형이 될 수 있다. (==**객체의 주소가 반환**==된다)
                
                ```java
                package com.tutorial.ch06;// 11/23(화)class Data {    int x;}public class ReferenceReturnEx {    public static void main(String[] args) {        Data d = new Data();        d.x = 10;        Data d2 = copy(d);  // d2에 객체의 주소 대입        System.out.println("d.x = " + d.x);        System.out.println("d2.x = " + d2.x);    }     static Data copy(Data d) { // type: object        Data tmp = new Data();        tmp.x = d.x;        return tmp; // 객체의 주소 반환    }}
                ```
                
    6. 지역변수
        1. 메서드 내부에 선언된 변수.
        2. 해당 메서드 내부에서만 사용할 수 있다.
        3. 메서드에 들어가는 매개변수도 지역변수의 하나라고 볼 수 있다.
    7. 메서드 호출 방법
        
        1. 선언된 매개변수의 갯수보다 더 많은 값 혹은 타입이 다른 값이 들어오면 에러가 발생하므로 주의.
        
        ```
        // 구구단 함수가 있다고 가정, prt99dan(int a, int b)prt99dan();int result = add (3, 5);  // 더하기 함수를 호출하고 결과를 result에 저장
        ```
        

  

1. JVM의 메모리 구조
    
    1. 3가지 주요 영역
        1. 메서드 영역
            1. 클래스가 사용되면 해당 클래스의 정보와 클래스 변수를 저장한다.
        2. 힙(heap)
            1. 인스턴스 + 인스턴스 변수가 생성되는 공간.
        3. 호출 스택
            1. 메서드 작업에 필요한 메모리 공간을 제공. 작업이 완료된 메서드의 메모리 공간은 자동으로 비워진다.
    
    🔥
    
    메서드가 호출되면 수행에 필요한 만큼 메모리를 스택에 할당.  
    메서드가 수행을 마치고나면 사용했던 메모리를 반환, 스택에서 제거된다.  
    호출 스택의 최상단 메서드가 현재 실행중인 메서드이며 그 아래의 메서드가 위의 메서드를 호출한 메서드이다.
    

  

1. 매개변수
    
    1. 기본형
        1. 기본형 값이 복사된다. (읽기만 가능)
    2. 참조형
        1. 인스턴스의 주소가 복사된다. (읽고 변경 가능)
            
            ```java
            package com.tutorial.ch06;// 11/23(화)class Data_1 {    int x;}public class ReferenceParamEx {    public static void main(String[] args) {        Data_1 d = new Data_1();  // 객체 생성        d.x = 10;  // 인스턴스 변수 x에 값 대입        System.out.println("main() : x = " + d.x);  // 10        change(d);  // 참조변수의 주소 삽입        System.out.println("After change(d)");        System.out.println("main() : x = " + d.x);  // 1000    }    static void change(Data_1 d) {        d.x = 1000;  // 참조변수 주소의 값을 변경; 원본이 수정되는 것.        System.out.println("change() : x = " + d.x);  // 1000    }}
            ```
            
    
      
    
2. 재귀호출
    1. 메서드 내부에서 자기 자신을 다시 호출하는 것.
        
        ```
        void method() {	method();}
        ```
        
    2. 메서드 입장에서는 자기자신을 호출하는 것이나 다른 메서드를 호출하는것은 차이가 없다.
        
        ```
        // 매개변수 n을 1씩 감소시켜가면서 재귀호출을 하다 n의 값이 0이 되면 중단하게 된다.void method(int n) {	if (n == 0)		return;	System.out.println(n);	method (--n);}
        ```
        
    3. 왜 사용하는가?
        1. 논리적 간결함
            1. 효율적으로 알아보기 어렵게 작성된 코드  
                vs 비효율적이어도 알아보기 쉽게 작성하는 코드.
            2. 어떤 작업을 반복적으로 처리해야 한다면 먼저 반복문으로 작성해보고 복잡할 경우 재귀호출로 간단히 할 수 있는지 고려해본다.
        2. 재귀호출은 비효율적이므로 간결함이 주는 이득이 큰 경우에만 사용할 것을 권장하고 있다.
    4. 매개변수는 유효한가?
        
        1. 무한 재귀호출 발생시 스택 오버플로우 에러가 발생할 수 있다.
        2. 어떤 값이 들어와도 에러없이 처리되는 견고한 코드를 작성해야한다.
        
          
        
3. 클래스(static) 메서드, 인스턴스 메서드
    
    1. 인스턴스 메서드
        1. 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 매서드
    2. 클래스 메서드
        1. 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다.
    
    ✅
    
    * 클래스를 설계할때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을  
    붙인다.  
      
    * 클래스 변수는 인스턴스를 생성하지 않아도 사용 가능.  
      
    * 클래스 메서드는 인스턴스 변수를 사용할 수 없다.  
      
    * 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.
    
    1. **==클래스 멤버는 인스턴스 멤버 호출 불가능==**: 인스턴스가 생성되지 않았을 수 있기 때문이다.
    
      
    
4. 오버로딩
    1. 하나의 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것.  
        (매개변수 개수나 타입을 다르게 만드는데 메서드 이름이 똑같은 케이스)
    2. 반환타입은 오버로딩 구현에 영향이 없다.
    3. 대표적인 오버로딩의 예: println 메서드 (PrintStream.println())
        
        ![[2021-12-03_17_11_25.png]]
        
    4. 장점
        1. 근본적으로 같은 기능을 가진 메서드의 사용 용이성 증대
        2. 메서드 이름으로 기능 유추 가능
        3. 이름 짓기 절약
    5. 가변인자
        1. 기존에는 메서드의 매개변수 개수가 고정적이었지만 jdk1.5부터 동적으로 지정이 가능해짐.
            
            ```java
            // '타입... 변수명'의 형식으로 선언
            public PrintStream printf(String format, Object... args) {...}
            ```